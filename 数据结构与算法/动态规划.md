> *求最值型dynamic programming*
>
> 1. 计数型 
>    1. 有多少种方式走到右下角
>    2. 有多少种方式选出k个数使得和是Sum
> 2. 求最大值最小值
>    1. 从左上角走到右下角路径的最大数字和
>    2. 最长上升子序列长度
> 3. 求存在性
>    1. 取石子游戏，先手是否必胜
>    2. 能不能选出k个数使得和是Sum

#### 一、动态规划组成部分一：确定状态

- 状态在动态规划中的作用属于定海神针  
- 简单地说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i]\[j]代表什么
- 确定状态需要两个意识
  - 最后一步是什么
  - 子问题

#### 二、动态规划组成部分二：转移方程

- f[x] = min{f[x-2]+1,f[x-5]+1,f[x-7]+1}

#### 三、动态规划组成部分三：初始条件和边界情况 

> 初始条件就是 用转移方程算不出来的， 需要人工定义的

- 两个问题：x-2，x-5，x-7小于0怎么办？什么时候停下来？
- 如果小于0，定义 f[-1] = f[-2] = ... = 正无穷
- 定义初始条件:f[0]  = 0 

#### 四、动态规划组成部分四：计算顺序

- **f[x] = min{f[x-2]+1,f[x-5]+1,f[x-7]+1}**
- 初始条件f[0]=0
- 然后计算f[1],f[2],,,f[27],从小到大计算
- **计算顺序的确定规则，当计算到f[x]时，f[x-2]、f[x-5]、f[x-7]都已经得到结果了**

#### 五、小结

- 求最值型动态规划
- 动态规划组成部分：
  1. 确定状态
     1. 最后一步（最优策略中使用的最后一枚硬币ak）
     2. 化成子问题（最少的硬币拼出更小的面值27-ak）
  2. 转移方程
     1. f[x] = min{f[x-2]+1,f[x-5]+1,f[x-7]+1}
  3. 初始条件和边界情况
     1. f[0]=0,如果不能拼出Y，f(Y)=正无穷 
  4. 计算顺序
     1. f[1],f[2],,,f[27],从小到大计算

#### 六、贪心算法

> greedy
>
> 从范畴上来看：
>
> Greedy⊂DP⊂SearchingGreedy⊂DP⊂Searching
>
> 即，**所有的贪心算法问题都能用DP求解，更可以归结为一个搜索问题，反之不成立**。

**实际上，贪心算法是在动态规划选中取贪心解，而动态规划则是全解**